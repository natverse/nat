update_igraph <- FALSE

.onLoad <- function(libname, pkgname) {
  try(cmtk.bindir(set=TRUE,check=TRUE),silent=TRUE)
  
  # Register file formats: neuron tracings
  registerformat('swc', read=read.neuron.swc, write=write.neuron.swc, 
                 class='neuron')
  # nb we cannot (yet) register formats with the same name but different classes
  registerformat('swcng', ext='.swc', read=read.ngraph.swc, class='ngraph')
  registerformat('neuroml', ext=c('.xml','.nml'), read=read.neuron.neuroml, 
    class='neuron', magic=is.neuroml, magiclen=8L)
  registerformat('fijitraces', ext=c('.traces','.xml'), read=read.neuron.fiji, 
    class='neuron', magic=is.fijitraces, magiclen=5L)
  registerformat('rds', read=readRDS, write=saveRDS, class='neuron')
  registerformat('rdsb', read=readBrotli, write=saveBrotli, class='neuron')
  registerformat('qs', read=readqs, write=saveqs, class='neuron')
  registerformat('hxskel', ext='.am', read=read.neuron.hxskel, 
                 write=write.neuron.hxskel, magic=is.hxskel,
                 class='neuron', magiclen=14L)
  registerformat('hxlineset', ext='.am', read=read.neuron.hxlineset, 
                 write=write.neuron.hxlineset, magic=is.hxlineset,
                 class='neuron', magiclen=14L)
  registerformat('vtk', ext='.vtk', write=write.vtk.neuron, class='neuron')
  
  # meshes to be read by read.neurons 
  # a bit of a cheat, since these won't have class neuron, but can usefully
  # represent neurons and go in a neuronlist
  registerformat('neuron.obj', ext='.obj', 
                 read=read.neuron.mesh, write=write.neuron.obj, class='neuron')
  registerformat('neuron.ply', ext='.ply', magic=is.ply, magiclen = 3,
                 read=read.neuron.mesh, write=write.neuron.ply, class='neuron')

  # image formats
  registerformat('nrrd', ext=c('.nrrd','.nhdr'), read=read.im3d.nrrd, 
                 write=write.nrrd, magic=is.nrrd,
                 class='im3d', magiclen=8L)
  registerformat('amiramesh', ext=c('.am','.amiramesh'), read=read.im3d.amiramesh, 
                 write=write.amiramesh, magic=is.amiramesh.im3d,
                 class='im3d', magiclen=14L)
  registerformat('vaa3draw', ext=c('.v3d','.v3draw'), read=read.im3d.vaa3draw, 
               magic=is.vaa3draw, class='im3d', magiclen=24L)
  
  # landmarks
  registerformat('amiralandmarks', ext=c('.landmarkAscii','.landmarkBin','.am','.amiramesh'),
                 read=read.landmarks.amira, write=write.landmarks.amira,
                 magic=is.amiratype("LandmarkSet"),
                 class='landmarks', magiclen=14L)

  registerformat('fijilandmarks', ext=c('.points'), read=read.landmarks.fiji,
                 write=write.landmarks.fiji,
                 magic=is.fijilandmarks, class='landmarks', magiclen=5L)

  registerformat('cmtklandmarks', ext=c('.landmarks'), read=read.landmarks.cmtk,
                 write=write.landmarks.cmtk, magic=is.cmtklandmarks,
                 class='landmarks', magiclen=13L)

  # surfaces
  registerformat('hxsurf', ext=c('.surf', '.am','.amiramesh'), read=read.hxsurf,
                 write=write.hxsurf, magic=is.amiratype("HxSurface"),
                 class='hxsurf', magiclen=14L)
  
  # deal with slow vertex sequences in igraph
  pvi <- packageVersion('igraph')
  if (pvi < "1.0.0") {
    # this is fast by default
  } else if (pvi > "1.0.1") {
    # we can turn off expensive vs.es return sequences
    igraph::igraph_options(return.vs.es = FALSE)
  } else {
    update_igraph <- TRUE
  }
  invisible()
  
  # Set the default plot engine
  if (is.null(getOption('nat.plotengine'))){
    options(nat.plotengine='rgl')
  }
}

.onAttach <- function(libname, pkgname) {
  if(is.null(cmtk.bindir()))
  {
    packageStartupMessage("Some nat functions depend on a CMTK installation. ",
                          "See ?cmtk and README.md for details.")
  }
  # igraph_options fails for v 1.0.0/1.0.1 so need to hack the function
  if(update_igraph)
    packageStartupMessage("nat: upgrading to igraph >1.0.1 is recommended to ",
                          "increase the speed of graph operations on neurons.")
  
  invisible()
}

# will store information about formats that we can read
.fileformats <- new.env()

# Will store stack of plotted rgl objects, ready for popping
.plotted3d <- new.env()

# Will store stack of plotted plotly objects, ready for popping
.plotly3d <- new.env()
.plotly3d$camera = list(up=list(x=0, y=0, z=1),
              center=list(x=0, y=0, z=0),
              eye=list(x=-0.1, y=-2.5, z=0.1))

.plotly3d$xaxis = list(title = "", zeroline = FALSE, 
                       showline = FALSE, showticklabels = FALSE,showgrid = FALSE)
.plotly3d$yaxis = list(title = "", zeroline = FALSE, 
                       showline = FALSE, showticklabels = FALSE,showgrid = FALSE)
.plotly3d$zaxis = list(title = "", zeroline = FALSE, ticks = "",
                        showline = FALSE, showticklabels = FALSE,showgrid = FALSE)
